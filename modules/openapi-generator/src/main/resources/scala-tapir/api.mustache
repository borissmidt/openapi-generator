{{>licenseInfo}}
package {{package}}

{{#imports}}
import {{import}}
{{/imports}}
import {{invokerPackage}}.JsonSupport._
import sttp.tapir._
import sttp.tapir.EndpointIO.annotations._
import sttp.model._
import scala.deprecated
import sttp.client3.SttpBackend
import sttp.tapir.client.sttp.SttpClientInterpreter
import java.time._
import sttp.tapir.generic.auto._

{{#operations}}
trait {{classname}}[F[_]] {
  import {{classname}}._
{{#operation}}
  def {{operationId}}(input: {{operationIdCamelCase}}Input): F[Either[Unit,{{operationIdCamelCase}}Output]]
{{/operation}}
}

object {{classname}} {
  val baseUrl: String = "{{{basePath}}}"
{{#operation}}
  {{#formParams.0}}
  case class {{operationIdCamelCase}}Form (
  {{#formParams}}
      {{>formPartField}}{{^-last}},{{/-last}}
  {{/formParams}}
  )
  {{/formParams.0}}

  @endpointInput("{{{path}}}")
  case class {{operationIdCamelCase}}Input (
  {{#authMethods}}
    {{#isBasicBasic}}
        @basic paramName: UsernamePassword.
    {{/isBasicBasic}}
    {{#isBasicBearer}}
        @bearer {{>fieldEncoder}}{{^-last}},{{/-last}}
    {{/isBasicBearer}}
    {{#isKeyInCookie}}
        no cookie authentication implemented.
    {{/isKeyInCookie}}
  {{/authMethods}}
  {{#requiredParams}}
      {{^isFormParam}} {{>paramType}} {{>fieldEncoder}}{{^-last}},{{/-last}}{{/isFormParam}}
  {{/requiredParams}}{{#requiredParams.0}}{{#optionalParams.0}},{{/optionalParams.0}}{{/requiredParams.0}}
  {{#optionalParams}}
      {{^isFormParam}}{{>paramType}} {{>fieldEncoder}}{{^-last}},{{/-last}}{{/isFormParam}}
  {{/optionalParams}}
  {{#formParams.0}}
      @body(MultipartCodec.multipartCaseClassCodec[{{operationIdCamelCase}}Form].rawBodyType, CodecFormat.MultipartFormData) body : {{operationIdCamelCase}}Form
  {{/formParams.0}}
  )

  object {{operationIdCamelCase}}Input{
    val endpointInput: EndpointInput[{{operationIdCamelCase}}Input] = EndpointInput.derived
  }

  case class {{operationIdCamelCase}}Output({{#responses}}{{#is2xx}}{{#headers}}
    @header {{>fieldEncoder}},{{/headers}}{{/is2xx}}{{/responses}}
    @jsonbody body : {{{returnType}}}{{^returnType}}Unit{{/returnType}}
  )

  object {{operationIdCamelCase}}Output{
    val endpointOutput: EndpointOutput[{{operationIdCamelCase}}Output] = EndpointOutput.derived
  }

  {{#javadocRenderer}}
      {{>javadoc}}
  {{/javadocRenderer}}
  {{#isDeprecated}}@deprecated{{/isDeprecated}}
  val {{operationId}} = endpoint
      .method(Method.{{httpMethod.toUpperCase}})
      .in({{operationIdCamelCase}}Input.endpointInput)
      .out({{operationIdCamelCase}}Output.endpointOutput)

{{/operation}}

  def bind[F[_]](t: {{classname}}[F]) = Seq(
{{#operation}}    {{operationId}}.serverLogic(t.{{operationId}}){{^-last}},{{/-last}}
{{/operation}}
  )

  def stub[F[_], P](url: Option[Uri], interpeter: SttpClientInterpreter, backend: SttpBackend[F, P]): {{classname}}[F] = new {{classname}}[F]{
{{#operation}}
    override def {{operationId}}(input: {{operationIdCamelCase}}Input): F[Either[Unit,{{operationIdCamelCase}}Output]] = {{operationId}}Client(input)
{{/operation}}

{{#operation}}
    private val {{operationId}}Client = interpeter.toClientThrowDecodeFailures({{classname}}.{{operationId}}, url, backend)
{{/operation}}
  }
}
{{/operations}}
